const SPREADSHEET_ID = '<<1mKekvx2BRbHL8NGY1zkzCKOgm98sauUBjLJTvFJPlck>>';
const SHEET_NAME     = 'シート1';
const LOG_SHEET      = 'server_log';
const API_VERSION    = 'v5-lock+normalize+id-rollback';
const CAPACITY       = { '1号船': 20, '2号船': 20 };

// -------- Utilities --------
function fmtDateYYYYMMDD(x) {
  if (x instanceof Date) return Utilities.formatDate(x, Session.getScriptTimeZone() || 'Asia/Tokyo', 'yyyy-MM-dd');
  // 文字列なら先頭10桁を使う（yyyy-mm-dd前提）
  return String(x).slice(0, 10);
}
function toHalfWidthDigits(s) {
  return String(s).replace(/[０-９]/g, ch => String.fromCharCode(ch.charCodeAt(0) - 0xFEE0));
}
function normalizeBoat(raw) {
  const s = toHalfWidthDigits(String(raw)).trim(); // 全角数字→半角、前後空白除去
  // 代表的な表記ゆれ吸収（例：「1 号船」「１号」など）
  const m = s.match(/^(\d+)\s*号?\s*船?$/);
  if (m) return `${m[1]}号船`;
  return s; // それ以外はそのまま
}
function toIntStrict(v) {
  // “3名”, “３”, " 5 " などを数字化。小数/NaNは拒否
  const n = Number(toHalfWidthDigits(String(v)).replace(/[^\d\-]/g, ''));
  if (!Number.isFinite(n) || !Number.isInteger(n)) throw new Error('people must be integer');
  return n;
}
function getSheets_() {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const data = ss.getSheetByName(SHEET_NAME) || ss.insertSheet(SHEET_NAME);
  const log  = ss.getSheetByName(LOG_SHEET)  || ss.insertSheet(LOG_SHEET);
  return { ss, data, log };
}
function logLine_(logSheet, type, obj) {
  const ts = new Date();
  logSheet.appendRow([ts, type, JSON.stringify(obj || {})]);
}

function sumPeopleFor_(dataSheet, dateStr, boatStr) {
  // シート1の全データを読み、対象日＆対象船の people を厳格加算
  const last = dataSheet.getLastRow();
  if (last < 1) return 0;
  const values = dataSheet.getRange(1, 1, last, 5).getValues(); // A:timestamp B:name C:date D:boat E:people
  let sum = 0;
  for (let i = 0; i < values.length; i++) {
    const [ts, name, cDate, dBoat, ePeople] = values[i];
    if (!cDate || !dBoat || !ePeople) continue;
    const rowDate = fmtDateYYYYMMDD(cDate);
    const rowBoat = normalizeBoat(dBoat);
    if (rowDate === dateStr && rowBoat === boatStr) {
      const n = Number(toHalfWidthDigits(String(ePeople)).replace(/[^\d\-]/g, ''));
      if (Number.isFinite(n)) sum += n;
    }
  }
  return sum;
}

function newReservationId_() {
  const props = PropertiesService.getScriptProperties();
  const key = 'RES_SEQ';
  const next = (Number(props.getProperty(key)) || 10000) + 1;
  props.setProperty(key, String(next));
  return `rsv_${next}`;
}

function findRowById_(dataSheet, rsvId) {
  // IDはB列(name)には入れない。IDは一意性を担保するため、今回は列Aのタイムスタンプとセットで列Fに入れる
  const last = dataSheet.getLastRow();
  if (last < 1) return -1;
  const idCol = 6; // F列に予約IDを格納
  const ids = dataSheet.getRange(1, idCol, last, 1).getValues().map(r => r[0]);
  for (let i = ids.length - 1; i >= 0; i--) {
    if (ids[i] === rsvId) return i + 1; // 行番号（1始まり）
  }
  return -1;
}

// -------- Main --------
function doGet() {
  return ContentService.createTextOutput(JSON.stringify({ ok: true, msg: 'ready', version: API_VERSION }))
    .setMimeType(ContentService.MimeType.JSON);
}

function doPost(e) {
  const startedAt = new Date();
  const { data, log } = getSheets_();
  let body, name, dateStr, boat, people, cap, sumBefore, sumAfter, remaining, rsvId, rowAdded = false;

  try {
    body = e && e.postData && e.postData.contents ? JSON.parse(e.postData.contents) : {};
    name   = (body.name || '').trim();
    dateStr= fmtDateYYYYMMDD(body.date || body.c || body.C || body.d); // 入力の曖昧さを吸収
    boat   = normalizeBoat(body.boat || body.dBoat || body.D || body.boatName);
    people = toIntStrict(body.people || body.p || body.P);

    if (!name)  throw new Error('name required');
    if (!dateStr || !/\d{4}-\d{2}-\d{2}/.test(dateStr)) throw new Error('date(yyyy-mm-dd) required');
    if (!boat)  throw new Error('boat required');
    cap = CAPACITY[boat];
    if (!Number.isFinite(cap)) {
      // 容量テーブル未ヒット（表記ゆれの可能性）
      throw new Error(`unknown boat "${boat}" (capacity not defined)`);
    }
    if (people <= 0) throw new Error('people must be >= 1');

    // ---- クリティカルセクション：ロック ----
    const lock = LockService.getDocumentLock();
    lock.waitLock(30 * 1000); // 30秒待機してロック獲得（同時POST抑止）

    try {
      sumBefore = sumPeopleFor_(data, dateStr, boat);
      remaining = cap - sumBefore;
      if (people > remaining) {
        logLine_(log, 'reject-pre', { date: dateStr, boat, cap, sumBefore, people, remaining, name });
        return json({ ok: false, reason: 'capacity_exceeded', cap, sumBefore, people, remaining, version: API_VERSION });
      }

      // 予約IDを先に採番し、F列に格納（後で確実にロールバックできる）
      rsvId = newReservationId_();

      // 追加
      const timestamp = new Date();
      // A:timestamp B:name C:date D:boat E:people F:rsvId
      data.appendRow([timestamp, name, dateStr, boat, people, rsvId]);
      rowAdded = true;

      // 直後に厳格再集計（他プロセスの割り込みを防ぐためまだロック中）
      sumAfter = sumPeopleFor_(data, dateStr, boat);
      remaining = cap - sumAfter;

      if (sumAfter > cap) {
        // ロールバック（IDで行を特定して削除）
        const row = findRowById_(data, rsvId);
        if (row > 0) data.deleteRow(row);
        logLine_(log, 'reject-rollback', { date: dateStr, boat, cap, sumAfter, people, name, rsvId });
        return json({ ok: false, reason: 'rolled_back', cap, sumAfter, remaining: cap - (sumAfter - people), version: API_VERSION });
      }

      logLine_(log, 'accept', { date: dateStr, boat, cap, sumAfter, people, remaining, name, rsvId });
      return json({ ok: true, cap, sumAfter, remaining, rsvId, version: API_VERSION });

    } finally {
      try { lock.releaseLock(); } catch (_) {}
    }

  } catch (err) {
    // 例外時：追加済みならロールバックを最後の手段で試みる
    try {
      const { data, log } = getSheets_();
      if (rsvId) {
        const row = findRowById_(data, rsvId);
        if (row > 0) data.deleteRow(row);
      }
      logLine_(log, 'error', { err: String(err), name, dateStr, boat, people, rsvId });
    } catch (_) {}
    return json({ ok: false, reason: 'error', message: String(err), version: API_VERSION });
  }
}

function json(obj) {
  return ContentService.createTextOutput(JSON.stringify(obj))
    .setMimeType(ContentService.MimeType.JSON);
}
